/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

const remark = __webpack_require__(1);

const $s = document.getElementById("source");
$s.textContent = __webpack_require__(2);

remark.macros.scale = function(percentage) {
  var url = this;
  return '<img src="' + url + '" style="width: ' + percentage + '" />';
};

const slideshow = remark.create();


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = remark;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = "class: center, middle\n\n# 2018/03 Ansible 導入会\n\nby Kenji Saitou\n\n---\n\n# 今日話す内容\n\nサーバの構成管理ツールの Ansible について使い方などを紹介していきます。\n\n---\n\n# 今日ターゲットにする人\n\n* Ansible やったことない人、さわったことない人\n* サーバ構成で忘れ物がある人\n  * 複数台セットアップで抜け漏れマン 😅\n* 自動化大好きマン\n\n---\n\nclass: center, middle\n\n# 我々は何に困っているのか？\n\n---\n\n## サーバの構成というつまらないタスク\n\n1. 😆 「`【本番用】サーバ構築手順書_20180101.docx`」\n\n---\n\n---\n\n## 自動化の欠如\n\n* 毎日の作業を手でやっている（ルーチンワーク）\n* 🐙「今日あれやった？」\n* 🐙「誰が手順知ってる？」\n* 😿「明日は休みたいです…」\n\n👻 人がマシンの前に座るのは、マシンを使うためであって、マシンに使われるためじゃない。\n\n---\n\nclass: center, middle\n\n# Ansible とは何か？\n\n---\n\n## 簡単にいえば、cron ＋ Web 画面\n\n* 簡単にいえば、Web 画面の付いた凄い cron\n  * 決まったタイミングで、決まった行動をする\n  * 行動の結果やログ・成果物は、Jenkins の Web 画面で見られる\n  * 世間では CI（Continuous Integration）ツールとして扱われているが、別にジョブスケジューラーとして大いに活用してもよい。\n    * 実際、開発インフラのジョブスケジューラーとしては便利。\n  * もちろん、この言葉では尽くせないぐらいの便利機能がたくさんある。\n* [https://ci.jenkins.io/ - 設置例](https://ci.jenkins.io/)\n\n---\n\n## アーキテクチャ\n\n* ≧ Java7 で動作。\n* データベースは不要。設定はほとんどすべて`${JENIKNS_HOME}`以下に XML ファイルで保存します。\n* プラグインアーキテクチャ\n* 1 _ マスターノード, n _ スレーブノード構成。\n* Java ベースとはいえ、Jenkins でよく使われている言語は Groovy。\n\n---\n\n## インストール\n\n* [設置](https://jenkins.io/download/)\n  * Java なので、Linux・Windows 問わず。\n    * ただし、Windows はファイルロックなどの仕様があるので、利用はおすすめしません。\n    * Windows 製品に依存するビルドをするからといって、Windows に設置する必要は一切ありません。\n    * 基本的にコンパイルターゲットとなる OS と Jenkins を設置する OS は別々で考えて OK。Java の動作は必要。\n  * JavaEE アプリとして、`*.war`になっているので Tomcat でデプロイすることも可能\n  * 最近の流行りは [🐳 Docker 🐳](http://knjname.hateblo.jp/entry/2015/02/10/040833)\n  * Linux ならパッケージマネージャ経由で入ります。イチバン楽なのはこれ。\n* バージョンは、LTS(長期サポート版) 使っておきましょう。\n* 個人的には Jenkins 本体のマシンは IO 性能が高いマシンがいいと思います。\n\n---\n\n## ジョブ\n\n* 基本構成単位\n* 構成要素\n  * いつ（トリガー：指定日時になったら、ソースが更新されたら、ボタンが押されたら、など）\n  * どこからソースをチェックアウトして （Git, Subversion）\n  * どんなビルドをして (コマンドの実行)\n  * どういう結果を残すのか（後続のジョブを起動するとか）\n  * 基本的にはコマンドで実行できるなら、なんでもできる\n* フォルダわけ可能\n* [プログラミングで生成可能。](http://qiita.com/mas0061/items/7288ba09ed7d99e46b54)\n\n---\n\n## ビルド\n\n* 1 ビルド＝ジョブが 1 回動いた結果\n* 構成要素\n  * 何をチェックアウトしたか\n    * Git ならコミットハッシュ、Subversion ならリビジョン番号\n  * ビルドログ\n    * コンパイル中のログなど\n  * ビルドアーティファクト\n    * ビルド結果としての成果物\n      * Java なら JAR ファイルとか\n\n---\n\n## ノード（マスターノード・スレーブノード）\n\n* 初心者は軽視しがちだが、Jenkins の大事な機能\n* Jenkins は複数台で実行できる\n* マスターノード\n  * マスターノード: 1 台のみ。Jenkins 本体が動く。Web 画面の提供、設定の保存、ビルド（ログなど）の保存\n  * スレーブノード: 0〜N 台で構成。マスターからの指示をうけてビルドを実行。\n    * 安いマシン、使わなくなったマシンはスレーブにしよう！\n* マスターノードが司令塔となり、スレーブノードにビルド指示を出してジョブを実行\n* [マスターノードでビルドをさせることもできますが、おすすめしません](http://knjname.hateblo.jp/entry/2014/05/03/190842)\n\n---\n\n## ノード（マスターノード・スレーブノード）\n\n* Windows アプリのビルドをしたい\n  * Windows マシンで構成したスレーブノードでビルドしましょう\n* Xcode でビルドをしたい\n  * macOS マシンで構成したスレーブノードでビルドしましょう\n* ビルド内容として、特定マシンからしかつながらないネットワークとやりとりする必要がある\n  * その特定マシンをスレーブノードにしましょう\n\n---\n\n## ノード（マスターノード・スレーブノード）\n\n* 基本的にスレーブノードはマスターノードと通信するエージェントを持って起動する\n* SSH\n  * マスターノードからスレーブノードにしたいマシンに SSH でつないでエージェントを起動　\\* 接続先に Java のインストールが必要\n* [JNLP](https://ja.wikipedia.org/wiki/Java_Web_Start)\n  * スレーブノードからマスターノードに JNLP プロトコルを使って接続しにいく\n  * クラウド上の Jenkins にファイアウォール経由でつなぎに行く時などに便利\n  * どちらかというと SSH よりこちらのほうがおすすめ\n  * [SwarmPlugin](https://wiki.jenkins.io/display/JENKINS/Swarm+Plugin) を付けば、アドホックにスレーブを起動して、動的に Jenkins に追加していける\n* 最近はスレーブは Docker で構成するのが流行り\n\n---\n\n## ビルドキュー\n\n* ノードごとの一度に並列に処理可能なジョブの数\n* 好きなだけ増やせます\n* 処理できない分はたまっていきます。キューが空いたら処理。\n* 当然増やした分だけノードが多忙になると他のジョブも遅延するようになります\n* どれぐらい並列化を許可するかは考えましょう\n  * 働かせすぎると、マスター ⇔ スレーブの間の接続が切れたり…\n  * ここらへんのビルド分散化の考えは、高いマシンを一台、よりは安いマシンを大量に、のほうがアプローチしやすい\n\n---\n\n## プラグイン\n\n* Jenkins はプラグインで機能を追加して利用するのが普通\n* 素のままは何もできません\n* 最近の Jenkins はおすすめプラグインをインストール時に勝手にリコメンドしてくれます\n* 更新がとまってるプラグイン、あげると互換性をなくすやつもいる…\n  * 安定大事な Jenkins では、プラグインのアップグレードも試験環境作って検証したほうがいいです\n    * 今日リリースが止まると困る Jenkins とか\n\n---\n\n## ビルド結果の掲示\n\n* チーム開発ではイチバン大事な要素ではないだろうか\n* テストの通過数、カバレッジの表示\n* 成果物の表示\n\n---\n\n## ログイン・権限・認可\n\n* 内部認証可能\n* LDAP 連携可能\n  * フォルダごとに LDAP グループで操作可否付与など細かく設定可能\n* OAuth もあったはず\n* 当然プラグインで拡張していけます\n\n---\n\n## ほか\n\n* [REST API 経由で操作・情報取得が可能。](http://knjname.hateblo.jp/entry/2014/11/12/220104)\n* マルチランゲージ可 \\* メジャーなツールは翻訳されている率が高いので、海外との協業が楽です。\n\n---\n\n## で、結局 Jenkins で何ができるの？\n\n* コマンド化・自動化できるなら、なんでもできる\n  * 逆に Jenkins で扱いたいなら人間が介入する要素は極力排除する必要がある\n  * なんでもできるので、自動化できるなら、無茶なビルドも可能\n    * ある Excel VBA マクロを Windows \\* 6 台で同時に動かしてビルドなど\n  * 特殊要件（）が多くなりがちな SI 案件にて選ばれる理由\n* 他の CI プロダクトだと、Docker 縛り（実質 Linux 縛り）があったりするが、Jenkins は無し\n\n---\n\n## なんでもできるかわりに、作り込まれすぎると面倒なこともある\n\n* その Jenkins、マシンがクラッシュしたら立て直せますか？他プロジェクトに流用できますか？\n  * 最近はこれへの反省もあって、プロジェクトに Jenkins のビルド内容を指示するファイルをチェックインしておくケースもおおい\n    * [Jenkinsfile](https://jenkins.io/doc/book/pipeline/jenkinsfile/)\n    * ほかの CI でも設定ファイルでビルドしたりしますよね\n\n---\n\n## 学びたい人向けへの資源\n\n私は Web と経験で学びました…が、\n\n* 本\n  * [Jenkins 実践入門](https://www.amazon.co.jp/dp/4774189286/)\n    * 読んだことないですが、新しい版も出てるし定番っぽい\n  * [継続的デリバリー](https://www.amazon.co.jp/dp/4048707876/)\n    * デプロイの自動化とは何か？美徳は何か？を教えてくれる\n    * 個人的におすすめ\n* [Jenkins の資格もあるよ](https://www.cloudbees.com/jenkins/jenkins-certification)\n\n---\n\nclass: center, middle\n\n# 私の体験談\n\n---\n\n## それは某巨大 Java プロジェクトで始まった…\n\n* 今国内で稼働しているシステムを海外向けに移植したい\n  * フレームワークの改修を行いたい。\n  * ついでに業務も移行したい。今まであった業務消えたりします。\n    * 大量の設計書も変更対象…！\n  * コード体系かわります。テーブル減ります。 etc\n  * 業務部分の開発は海外にオフショアします。\n    * 言語の壁！\n      * 互いにノンネイティブ同士の英会話！\n    * 価値観の壁！\n      * 忖度なんて期待できない！明確なものが必要！\n    * 距離の壁！\n      * 遠い海外、いちいちエラーでミーティング開きますか？\n\n---\n\n## そのまま徒手空拳やってたら死亡するフラグ\n\n* 大規模だもの、みんな平気でやらかします\n  * ビルドが通らないコードをコミットする\n    * そして気づかない\n    * 「僕は悪くない」\n  * 大人数の誰一人も失敗しない場合にだけ動く仕組みなんか運用できないよねー\n* なんとかしないとね！\n  * → そうだ CI しよう！\n\n…というような導入動機が明確にあったわけではないですが、なんとなく改変に向けて危機感を感じたのでプロジェクトで提案して始めることにしました。\n\nあなたなら、どういう手を打ちますか？またマネージメントですか？\n\n---\n\n## 気合いのマネジメント（）による対処は悪手\n\n* マネジメントという名の「気合いで解決」　どう思いますか？\n* 全ては仕組みの問題である\n  * 人はミスをする\n    * そしてミスを誘発する仕組みがある\n    * ミスを問題視せざるをえない仕組みがある\n    * 個人の注意力に依存する仕組みがある\n  * ミスにすぐ気づけるとしたら？\n  * ミスが問題にならないとしたら？\n\n注意力という個人の資質に頼るのはやめましょう。\n\n---\n\n## だから、CI (Continuous Integration)、はじめました\n\nとりあえず適当なマシンを調達して Jenkins をインストールした\n\nまあ、まだ価値を理解していないところでは、予算はつかないですね…\n\nさて、どこから始めるよう？\n\n---\n\n## まずはコンパイルチェックから\n\n* とりあえずプロジェクトのコンパイルが通るかだけをチェック\n  * ビルドロジックがコマンドラインで自動実行できる必要がある\n* 数分ごと、リポジトリにコミットがあったら、Java+Ant でコンパイル。\n  * 全自動で Ant でコンパイルできるようにスクリプトを書いた。\n    * IDE でコンパイル通るだけとか、問題外…。コマンドラインで自動化できるかが Jenkins でのビルドの鍵です。\n* 単体テストをやるのは難しいが、コンパイルチェックだけならなんとかなる。\n  * CI 導入のはじめとしてはおすすめの課題。\n\n---\n\n## まずはコンパイルチェックから\n\n* スクリプト言語だから無理？\n  * スクリプト言語でもある程度の文法チェッカは備えていることは多いです。\n\n```console\n$ bash -n target.sh\n```\n\n* コンパイルエラーは 0 件にするように注意。みんな自主的に Jenkins をチェックす る流れ。\n\n---\n\n## → 効果\n\n* ひとまずはソースを安心してみんなで改変できるようになった。\n* よくある、結合試験期間が来るまで闇鍋状態を回避できた。\n  * やっぱり悪の芽は早めに詰むのに限ります。\n  * 👿「俺のマシンでは問題ない」 ← これを防げた\n\n---\n\n## ソースコード静的解析もやった\n\n* 静的解析ツールをビルドで使い始めた\n  * 潜在的なコードの問題を発見したりするやつ\n    * [Findbugs](http://findbugs.sourceforge.net/)\n    * [Checkstyle](http://checkstyle.sourceforge.net/)\n  * ステップ数解析 とかも\n  * [SonarQube](https://www.sonarqube.org/) とかありますね\n    * 最終的に Jenkins だけで十分じゃん、で使わなくなった\n    * （指標が難しすぎるという声もいただきました。自分たちのレベルにあわせましょう。）\n* 比較的施策が簡単なのでおすすめ\n* 目標\n  * やばいエラーは 0 件\n  * 軽微なものはできれば Fix、無理なら応相談\n  * チェックツールが重すぎるなら訂正\n\n---\n\n## → 効果\n\n* 問題・既存バグがあらわになる\n  * 問題が実際出るか観察して対処\n* コーディング規約を守らせることができる\n* オフショア人材についても、機械が出すエラーに対する対処という面で、守っているか守っていないかはっきりしているので、価値観の違う相手でも通用しやすい指標となった\n  * （ただし、裏でブリッジ役が教育しまくってます）\n\n---\n\n## もっともっと静的解析 👹\n\n* もし、僕一人が大量の成果物をチェックするプログラム書いて、事前にプロジェクト全体のエラーが分かったとしたらすごくお得じゃない？\n  * 実際に人の手で調べていたが、機械化可能なチェックを Jenkins 上でチェックする\n  * 過去にやらかした問題について、機械でチェック可能なら Jenkins 上でチェックする\n    * 過去の問題が二度と発生しないことを保証できる\n  * 同時に成果物についてのレポートとかも出しちゃう\n    * 画面遷移図 など\n\n---\n\n## カスタムのソースコードチェッカを作ったりしました 👹\n\n* プロジェクトの規約に沿った成果物が出来上がっているかチェック\n* 海外向けなので日本語が残ってないかチェック\n* 特定のコード体系に基づく文字列が仕様書に存在するかチェック\n  * 大規模故、メッセージコードとか規約が大量にあります。これを人がチェックする？バカバカしいでしょう。\n\n```java\n// Check if `MSG0001` exists in our specifications.\nString message = MessageUtils.formatMessage(\"MSG0001\", \"This cannot be done.\");\n```\n\n* XML 設定ファイルなどの整合性チェック\n  * 定義が見つからないものを指していないか？2 重に定義していないかなど…\n  * XPath が死ぬほど役に立った。単純に技術力でできるチェックの幅は変わってくる。\n* いろんなものが機械的にチェックできる規約になっていると楽\n\n---\n\n## → 効果\n\n* 大規模故、チェッカの作成工数以上の効果が得られた\n* ボロボロ出てくる大量のバグ候補たち\n  * お決まりのように、既存のソースからも出てるじゃん！どんだけ〜\n* しかし、こういうものも\n  * 偽陽性 (false positive): エラーじゃないのにエラーになるもの\n    * ホワイトリストなどを作成して除外\n  * 偽陰性 (false negative): エラーなのにエラーになっていないもの\n    * チェック内容の見直し\n* 人の手でチェックしているぐらいなら、機械化して毎日流そう。\n\n---\n\n## ドキュメント生成もやりました\n\n* Java なら Javadoc とか\n* Excel のレポートとか\n* 一日に一度程度生成で済む。\n  * CI をまわしていると、計算機のリソースがだんだん足りなくなってくるのですが、一日に一度程度のタスクならいくら増やしてもそこまで負担にはならない。\n\n---\n\n## リリース・デプロイの自動化 😭\n\n* 最初からやりたかったことの一つ。\n* リリースフローを定義し、これに従ってリリースしてもらう\n* 基本的な発想は\n  * 人間が介在しなくてもリリースできるようにしよう\n    * 人は必ずいつかミスをする\n    * Q. 99% ミスをしない人間がいたとして、 3 ヶ月 60 日 作業を毎日繰り返したとして、一度も失敗しない確率はいくつ？\n      * A. 55% (= `0.99^60`)\n  * SI 案件のリリースフローは、承認フローを回して資材を出し入れ＋ビルド＋デプロイ＋通知するだけなのだから、工夫すれば機械化可能なのでは？\n\n---\n\n## 具体的なリリース・デプロイの流れ\n\n* リリース申請を Redmine のチケットで実施\n* 承認済みリリース申請のチケットを Jenkins が取り込んで、ソースのマージを実施 （作りこみ）\n* マージしたソースからリリース資材作成\n* 結合環境リリースであれば、そのまま直接リリース\n  * 🌛 日中にマージ、深夜に自動リリース、翌朝テスト可能（たまに例外で緊急リリース）\n    * スケジュールが決まっていると、それに応じて人が動ける！\n  * 本番環境リリースであれば、リリース可能な資材の作成まで実施\n* [Jenkins ではビルドパイプラインという仕組み](http://knjname.hateblo.jp/entry/2014/05/06/202603)を使うことにした\n\n---\n\n## → 効果\n\n* いちいち面倒なリリース手順を踏まないのでリリースがまったく苦痛じゃなくなりました。\n  * そもそも手を動かす必要がほとんどなくなった。\n  * リリースフローが途中で落ちた時は、原因を調べて当人に Redmine でチケット投げ\n* 今までいた、リブ管、リリース担当者というロールが不要になりました。\n* リリース申請間で何が変更されたのか誰でも分かるようになりました。\n\n---\n\n## Excel の仕様書チェック\n\n* 個人的に Jenkins の過剰利用だとは思うが、かなり心血を注いでやった\n* 具体的には、大量の Excel 仕様書・項目書を…\n  * VBA を Jenkins で動かしてチェック\n    * Jenkins から PowerShell、PowerShell から Excel マクロを起動する仕組み\n      * はっきりいって不安定な上、💩 面倒な仕組み\n* Office は自動化には向いていない… しかし Excel VBA ぐらいしか自動化ツールが普及していない\n* そもそも VBA にしたって書く人が気をつけないとフル自動化はできない\n* 実際は Windows の VM を KVM で立ち上げ、VBA を動かすインスタンスとして運用\n\n---\n\n## → 効果\n\n* たしかに、そこに需要がありました。そして効果もありました。\n* 設計書の単純ミスの早期防止。\n* エラー件数の見える化\n  * 今まで人がチェッカツールなどを動かしていたが、どれだけのエラーを Fix できていたか全体把握が無理だった。\n* Jenkins に掲示されることでエラーの Fix 状況が把握できるようになった。\n\n---\n\n## ユニットテスト自動化\n\n* これもやりたかったが、ハードルがあった\n* プロジェクトの規約上、個々人で単体テスト実施をやってはいたが… 実際にこれを Jenkins で行うとなると…\n  * 外部とのやり取りがないコードはテストが超簡単\n\n```java\npublic static int add(int x, int y) { return x + y; }\n```\n\n* 外部とのやり取りがあるコードはテストが難しい、そもそもテストのことを考えていないコードが大量。\n\n```java\n// 手でDBやファイルを編集しないと動かない。\ndatabaseQuery(\"SELECT * FROM foobar WHERE x = ?\", foobar.getId());\n```\n\n---\n\n## ユニットテスト自動化\n\n* ポータブルにテストする仕組みを作成して、実施。\n  * テストの前に DB を初期化させたり、強力なモック化の手段([JMockit](http://jmockit.org/))を用意したりなど…\n* Jenkins 上ではポータブルに構築されたテストを実施。\n  * テストの成否、カバレッジ率を取得。\n  * ローカルマシンに依存するテストを作るな、とガイドラインを作ったりしました。\n\n---\n\n## → 効果\n\n* 回帰試験の自動化\n  * きちんと JUnit できてますよね？を自動化\n  * 単純にプロジェクトに安心感を持てるようになった\n  * フレームワークの変更で業務が落ちるかどうか把握可能になった。\n* プロジェクト大きすぎて、テストに時間がかかりまくる\n  * なるべくテスト実施の単位を分ける\n    * → アプリごとバラバラに実施して、実施結果はマージして取り扱う\n\n---\n\n## 開発環境について見るべき情報が多すぎる問題\n\n* 割りとよくある\n* Jenkins にいろいろエラーを収集させているが、グラフが多すぎて毎日見るのが面倒\n* 収集用のダッシュボード SPA アプリを作成 (AngularJS)\n  * 開発サーバのトップページポータルになるようなものを作成\n  * WebAPI でエラーを集計して、ひと目でいろんなエラーがわかるように\n  * いろんな開発用サービスへのリンクを用意\n  * 自分にアサインされている or 放置されている Redmine のチケットがわかるように\n\n---\n\n## ほか\n\n* 本当に 1 から 100 まで全部 Jenkins でやった\n  * DB のバックアップ取得、リポジトリの掃除（放置されたロックなど）\n  * UI 描画テストの自動化、開発サーバのユーザアカウント追加の自動化\n  * 面白そうなら Jenkins でジョブ追加\n  * 開発環境での自動化は全部 Jenkins という名の Web 画面付き cron に投げる\n    * みんなが見られる\n  * 最終的なジョブ数は 800 近くぐらい（一人で管理するんですよ）\n* ここまで使い倒した人間はほぼ地球上にいないと思う\n  * もはや Jenkins は飲み物\n\n---\n\n## っていうか\n\n* いろんな開発を効率化するために最終的に自分で開発インフラの殆どを引き取った\n  * バージョン管理システム\n  * チャット\n  * ビルド方式\n    * システム全体で Jenkins を使って自動デプロイするように誘導していった\n\n---\n\n## ん、これって？\n\n* 新たな属人化が発生してない？\n  * 👿 ネ申 👿 の誕生\n  * でも楽になってはいるし、ミスもおきていない、バグも早期に発見できている、定時で帰れる…\n* 一応僕がいなくとも、回ってはいる模様\n  * まあでも僕がいなくなったら嫌なことになりますね\n* 開発インフラはみんなで保守していくチーム体制が大事\n  * **みんな興味持って！**\n\n---\n\n## 他のプロジェクトへ構築ヘルプに行くの巻\n\nこういう取り組みを通じて非常に効果をあげたことで、そこらへんに評判が広がり、他プロジェクトに Jenkins などを設置しにいくこと数度。\n\n* 残念なが全般的にうまくいかなかった\n  * 抵抗される、無視される、放置される\n* ツールは設置できるが、カルチャーを設置するのはとっても難しい\n  * いろんな人が理解して、布教して、便利さや考え方を理解してもらう必要がある\n  * 一人だけが頑張っても無駄\n\n---\n\n## 他のプロジェクトへ構築ヘルプに行くの巻\n\n* 継続してプロジェクトにフィットさせる人材が必要\n* 開発インフラ構築だけ切り離す、なんてのは夢の夢\n* 開発インフラの価値が理解されないこともある\n  * 手でビルドリリース、共有フォルダで管理を当然だと思っている人たちが大勢いる\n  * 私達で主導権を握って開発インフラを構築する主体性をうまくできないと全員で詰む\n\n---\n\n## CI(継続的インテグレーション) を導入することへの提言\n\n* やれば効果が確実にあがるという意味では、CI は本当に導入が楽な施策ですよ。\n  * やって効果があるかわからないことはいっぱいある\n  * CI はやれば効果が出る\n* 便利な仕組みを知った開発者が他所にいって、その便利な仕組みを広めていけば、いいと思った\n  * 一度便利な仕組みになれると以前の不便には耐えられなくなる\n\n---\n\n## CI(継続的インテグレーション) を導入することへの提言\n\n* 自動でビルドをまわすのは義務\n* プロジェクト初期でもうリリースまでつないでおけ\n  * 💩 結合あたりで遅延こいて便秘して爆発するプロジェクトはたくさんある 💩\n  * スルーっとビルドパイプラインを通しましょう。どんどんデプロイできるようにしておきましょう。\n  * 実製品が動いていることほど説得力があるものはない。\n  * デリバリーまで繋がっていれば、末端業務が死んでもだいたい問題ない（暴言）\n\n---\n\n## 資料はこちら\n\n* https://github.com/knjname/2017-07_IntroductionToJenkins\n* https://knjname.github.io/2017-07_IntroductionToJenkins/\n\n---\n\n## Q and A\n\n* Q. これ Jenkins そのものじゃなくて、チームとしての啓蒙や教育がちゃんとしていたということ？\n  * A. その通り。そこはしつこくねばっこく担当者が実施していた。\n  * A. 身も蓋もない話をすると、いい人材が揃っていたからうまくいった。悪い人材ではいいツールも悪い結果にしかならない。\n* Q. リブ管、リリース担当者がいなくなったというのは、業務のリリース判定は誰がやっていたのか？全体資材の調停は誰がやっていたのか？\n  * A. 業務のリリース判定は、そもそも当該業務を知らないとできないことなので、業務のリーダークラスが行うようにしていた。全体の調停は、共通チームが行うようにしていた。\n  * A. いずれにしろ、リリース専用のロールは置かず、全体でリリースロールを兼務していた。総合的なオーケストレーションは私。\n* Q. Jenkins は案件ごとたてるイメージか？\n  * A. そのイメージ。Jenkins のアップグレードなどの影響範囲から考えても妥当。\n\n---\n\nclass: center, middle\n\nおわり\n"

/***/ })
/******/ ]);